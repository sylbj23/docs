---
title: "api"
---
# Get an end user

> Gets an end user by ID.

This API is intended to be used by the developer's own backend, and is authenticated using the developer's CDP API key.



## OpenAPI

````yaml get /v2/end-users/{userId}
openapi: 3.1.0
info:
  title: Coinbase Developer Platform APIs
  description: >-
    The Coinbase Developer Platform APIs - leading the world's transition
    onchain.
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
  version: 2.0.0
  contact:
    name: Coinbase Developer Platform
    email: cdp@coinbase.com
    url: https://cdp.coinbase.com
servers:
  - url: https://api.cdp.coinbase.com/platform
    description: The production server of the CDP APIs.
security:
  - apiKeyAuth: []
tags:
  - name: End User Accounts
    x-audience: public
    description: >-
      The End User Accounts APIs enable developers to manage the accounts
      belonging to their end users. End User Accounts are typically created by
      end users themselves when they sign in to the developer's application via
      the CDP Web SDK. However, developers also have the option of creating End
      User Accounts on behalf of their end users. Critically, developers do not
      have the ability to sign transactions or messages on behalf of the end
      user; only end users can do this.


      End User Accounts APIs are accessed by the developer's servers and
      authenticated by the developer's CDP API key.
  - name: EVM Accounts
    x-audience: public
    description: >-
      The EVM Account APIs enable you to create and use accounts across
      blockchains that are compatible with the Ethereum Virtual Machine (EVM).


      An **account** is a private/public key pair that is used to sign
      transactions and messages. The private key is generated and used only in
      CDP's Trusted Execution Environment (TEE), and never exposed to Coinbase
      or the developer.


      An EVM account is identified by its **address**, which is a 0x-prefixed
      hexadecimal string. The same address can be used across multiple EVM
      networks.


      Accounts can optionally be assigned an **account name** at creation time
      for easier identification in subsequent API calls. EVM account names must
      be globally unique across all EVM accounts in the developer's CDP Project.


      ## Authentication


      The EVM Account API uses two layers of authentication to ensure the
      security of your accounts' private keys:


      - **CDP Secret API Key**: This key is used to authenticate all requests to
      the entire suite of
         REST APIs offered on Coinbase Developer Platform.
      - **Wallet Secret**: This secret is used specifically to authenticate
      sensitive wallet operations
        to `POST` and `DELETE` endpoints in the EVM and Solana Account APIs.


      To learn more about creating and using these keys, visit our
      [Authentication
      docs](https://docs.cdp.coinbase.com/api-reference/v2/authentication).


      <Tip>



      **Use our SDK**



      The [CDP SDK](https://github.com/coinbase/cdp-sdk) automatically
      authenticates requests using your CDP Secret API Key and Wallet Secret.
      Use the CDP SDK for a more convenient access to our APIs.



      </Tip>
  - name: EVM Smart Accounts
    x-audience: public
    description: >-
      The EVM Smart Account APIs enable you to create and manage Smart Account
      wallets across EVM-compatible blockchains.


      A **Smart Account** is an EVM account that enables enhanced functionality
      such as account abstraction, batched transactions, and gas sponsorship
      through [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337). Smart
      Accounts allow users to create and manage "user operations" instead of
      traditional EVM transactions.

      Smart Accounts are identified by their **address**, which is a 0x-prefixed
      hexadecimal string.

      Smart Accounts can be assigned an optional **name** at creation time for
      easier identification in subsequent API calls.


      A Smart Account has a single owner, which is another EVM Account which
      signs the Smart Account's transactions. The owner can be a CDP EVM
      account, or an account managed solely by the developer.
  - name: EVM Swaps
    x-audience: public
    description: >-
      A swap refers to the act of exchanging one token for another. The EVM Swap
      APIs enable you to create and manage swaps. A swap process involves:

       1. A user approves token spending via smart contract.
       2. The smart contract determines the exchange rate and facilitates the swap between the two tokens.
       3. The transaction is completed atomically and the tokens are transferred to the user's wallet.

      The Swap API supports:

       - **Getting a price**: Estimate the amount of tokens you will receive for a given amount of exchanged tokens.
       - **Creating a swap quote**: Return a swap transaction payload that you can use to sign and submit in order to execute the swap.

      For the easiest experience creating, signing, and submitting a swap, we
      recommend using the [CDP SDK](https://github.com/coinbase/cdp-sdk/).

      - [Python SDK
      examples](https://github.com/coinbase/cdp-sdk/tree/main/python#evm-swaps)

      - [TypeScript SDK
      examples](https://github.com/coinbase/cdp-sdk/tree/main/typescript#evm-swaps)


      To read more about using the EVM Swap APIs, please see our [Swap API
      docs](https://docs.cdp.coinbase.com/swaps/docs/welcome).
  - name: EVM Token Balances
    x-audience: public
    description: >-
      The EVM Token Balances APIs enable you to retrieve the balances of EVM
      addresses.

      This includes tokens (i.e. ERC-20s) and the native gas token of the
      network.

      ## Denomination

      - 'amount' is denominated in the smallest indivisible unit of the token.
      For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s,
      the smallest unit is the unit returned from `function totalSupply() public
      view returns (uint256)`.

      - 'decimals' is the exponential value N that satisfies the equation
      `amount * 10^-N = standard_denomination`. The standard denomination is the
      most commonly used denomination for the token.

        - In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18.
        - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.
  - name: Faucets
    x-audience: public
    description: >-
      The Faucet APIs enable you to request funds on supported test networks.
      Faucets are for testing purposes and make development easier by providing
      a source of funds.
  - name: Onchain Data
    x-audience: public
    description: >-
      Query and analyze blockchain data with high performance and reliability.
      Features include real-time token balances, token discovery, and
      transaction history with freshness, accuracy, and completeness like never
      before.
  - name: Onramp
    x-audience: public
    description: >-
      The v2 Onramp APIs are an evolution of our [v1
      APIs](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/),
      designed to make the fiat-to-crypto experience feel native to your
      applications for higher conversion and less friction. These APIs only
      cover a subset of Coinbase Onramp functionality as described below, for
      all other use cases please refer to our [v1
      APIs](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/).


      ## Supported Use Cases


      #### Apple Pay Onramp


      This use case allows you to offer an Apple Pay onramp experience with
      debit cards in your app without users needing to create or log into a
      Coinbase account. Our API returns a `paymentLink` URL that renders an
      Apple Pay button for you to load in a webview or iframe in your app,
      making the onramp experience feel native to your application.


      Refer to our [detailed integration
      guide](https://docs.cdp.coinbase.com/onramp/headless-onramp/overview) for
      more information on the limitations and requirements of this use case. See
      our [onramp mobile demo
      app](https://github.com/coinbase/onramp-demo-mobile) for a reference
      implementation.


      #### Hosted UI Onramp


      This use case enables you to offer a full-featured onramp experience by
      redirecting users to a Coinbase-hosted page where they can choose to log
      into their existing Coinbase account or proceed as a guest. The Onramp
      Session API generates secure, single-use Onramp URLs with customizable
      parameters, allowing you to control available payment methods, preset
      transaction amounts, and cryptocurrencies for a tailored user experience.


      Refer to our
      [guide](https://docs.cdp.coinbase.com/onramp/coinbase-hosted-onramp/overview)
      for implementation details and customization options for this use case.
  - name: Policy Engine
    x-audience: public
    description: >-
      The Policy Engine APIs evaluate policies (a set of rules) to govern the
      behavior of accounts or projects, such as enforce allowlists and
      denylists.

      - A **policy** is a collection of `rules` with defined criteria.

      - Each **rule** contains a specified `action`, `operation`, and
      `criteria`:
        - An `action` can either `accept` or `reject` a transaction if the criteria in the rule are met.
        - `criteria` is an array of logical expressions. All parameters must evaluate to true for the action to be applied.
        - An `operation` corresponds to a CDP v2 API:
            - `signEvmTransaction` or `signSolTransaction` for signing transactions (to set a transaction limit).
            - `sendEvmTransaction` for signing a transaction, and sending it to a supported network.
            - `signEvmHash` for signing an arbitrary 32 byte hash.
            - `signEvmMessage` for signing an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) message.
            - `prepareUserOperation` for preparing user operations on a smart account.
            - `sendUserOperation` for sending user operations using a smart account.
      - A **rule** indicates how an operation should behave, specifying whether
      a request with defined criteria should be accepted or rejected.

      ## Policy Scope

      Policies can be applied at the project and/or account level:

      - **Project-level policy**: A `project`-level policy applies to all
      accounts in a CDP Project. Only one project-level policy can be applied to
      accounts within a CDP Project at any given time.

      - **Account-level policy**: An `account`-level policy applies to one or
      more accounts. An account
        can have at most one account-level policy at any given time.

      Thus, a single account can be assigned at most two policies at any given
      time: one project-level policy and one account-level policy.


      Scope is specified in the `scope` field of a policy:

      ```json {
        "description": "Project-level policy",
        "scope": "account",
        ...
      ```

      ## Policy Evaluation

      **Project-level policies** are evaluated first, followed by
      **account-level policies**.

      The Policy Engine will process the request against each rule in the order
      it is defined within the `rules` array:

        1. If the rule's `criteria` (processed as a logical **AND** operation applied to a list of independently evaluated boolean expressions) are met, `accept` or `reject` behavior is applied immediately and the engine stops further evaluation of the policy.
        1. If after policy evaluation, no rule's `criteria` are met, the engine moves to processing the next policy (i.e., an `account`-level policy).
        1. If no further policies exist, the request is rejected.

      For example, the following policy is a project-level policy with two
      rules. The Policy Engine will:

         1. **Evaluate the first rule:** For a `signEvmTransaction` request, accept the request if the transaction is less than or equal to 1000000000000000000 wei OR
         1. **Evaluate the second rule:** if the request is a `signEvmTransaction` request, accept the request if the transaction is less than or equal to 2000000000000000000 wei AND the request is made to the address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`.
         1. **If the request does not meet the criteria of either rule**, the engine will move on to evaluate an `account`-level policy (if one exists).
         1. Otherwise, the request is rejected.

      Rules are processed in the order they are defined. Once a rule applies to
      an operation, subsequent rules are ignored.

      ```json

      {
        "description": "Project-level policy",
        "scope": "project",
        "rules": [
          {
            "action": "accept",
            "operation": "signEvmTransaction",
            "criteria": [
              {
                "type": "ethValue",
                "ethValue": "1000000000000000000",
                "operator": "<="
              }
            ]
          },
          {
            "action": "accept",
            "operation": "signEvmTransaction",
            "criteria": [
              {
                "type": "ethValue",
                "ethValue": "2000000000000000000",
                "operator": "<="
              },
              {
                "type": "evmAddress",
                "addresses": [
                  "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"
                ],
                "operator": "in"
              }
            ]
          }
        ]
      }

      ```


      ## Policy Application


      Project-level policies are applied to all accounts in a CDP Project. They
      will apply retroactively even if the project-level policy is created after
      the account was created. To disable a project-level policy, you must
      remove the project-level policy from the CDP Project using the
      `deletePolicy` operation.


      Account-level policies can be applied in two ways:

      - By specifying the `accountPolicy` field in the request body of the
      `createEvmAccount` and
        `createSolAccount` operations.

      - By specifying the `accountPolicy` field in the request body of the
      `updateEvmAccount` and
        `updateSolanaAccount` operations.


      ## Criteria


      The following criteria are supported:


      ### SignEvmTransaction Criteria

      #### ethValue

      A criterion based on the value of the transaction. The transaction's
      `value` field is compared to the criterion's `ethValue` field using the
      `operator` field.

      #### evmAddress

      A criterion based on the recipient address of the transaction. The
      transaction's `to` field is compared to the criterion's `addresses` field
      using the `operator` field.

      #### evmData

      A criterion based on encoded transaction data that evaluates the function
      being called, as well as any number of arguments accessed by either name
      or index. Currently this criterion only supports primitive types;
      `string`, `bool`, `uint(8,16,32,64,256)`, `int(8,16,32,64,256)`,
      `address`, and both fixed and dynamic length `bytes`.

      #### netUSDChange

      A criterion based on the USD denominated market value of assets being
      transferred, or exposing the sender to. The types of assets included in
      the calculation include native assets, `ERC20`, `ERC721`, and `ERC1155`
      tokens. The sum total USD amount of assets being transferred and exposed
      is compared to the criterion's `changeCents` field using the `operator`
      field. If signing a testnet transaction, then this criterion configuration
      will be ignored.

      ### SendEvmTransaction Criteria

      #### ethValue

      A criterion based on the value of the transaction. The transaction's
      `value` field is compared to the criterion's `ethValue` field using the
      `operator` field.

      #### evmAddress

      A criterion based on the recipient address of the transaction. The
      transaction's `to` field is compared to the criterion's `addresses` field
      using the `operator` field.

      #### evmNetwork

      A criterion based on the intended network of the transaction. The
      `network` field in the `sendEvmTransaction` request body is compared to
      the criterion's `networks` field using the `operator` field.

      Valid networks for this criterion include:
        - `base`
        - `base-sepolia`
        - `ethereum`
        - `ethereum-sepolia`
        - `avalanche`
        - `polygon`
        - `optimism`
        - `arbitrum`

      #### evmData

      A criterion based on encoded transaction data that evaluates the function
      being called, as well as any number of arguments accessed by either name
      or index. Currently this criterion only supports primitive types;
      `string`, `bool`, `uint(8,16,32,64,256)`, `int(8,16,32,64,256)`,
      `address`, and both fixed and dynamic length `bytes`.

      #### netUSDChange

      A criterion based on the USD denominated market value of assets being
      transferred, or exposing the sender to. The types of assets included in
      the calculation include native assets, `ERC20`, `ERC721`, and `ERC1155`
      tokens. The sum total USD amount of assets being transferred and exposed
      is compared to the criterion's `changeCents` field using the `operator`
      field. If sending a testnet transaction, then this criterion configuration
      will be ignored.

      ### SendUserOperation Criteria

      #### ethValue

      A criterion based on the value of the user operation. The operation's
      `value` fields are compared to the criterion's `ethValue` field using the
      `operator` field.

      #### evmAddress

      A criterion based on the recipient address of the operation. The
      operation's `to` fields are compared to the criterion's `addresses` field
      using the `operator` field.

      #### evmData

      A criterion based on encoded transaction data that evaluates the function
      being called, as well as any number of arguments accessed by either name
      or index. Currently this criterion only supports primitive types;
      `string`, `bool`, `uint(8,16,32,64,256)`, `int(8,16,32,64,256)`,
      `address`, and both fixed and dynamic length `bytes`.

      ### PrepareUserOperation Criteria

      #### ethValue

      A criterion based on the value of the user operation. The operation's
      `value` fields are compared to the criterion's `ethValue` field using the
      `operator` field.

      #### evmAddress

      A criterion based on the recipient address of the user operation. The
      operation's `to` fields are compared to the criterion's `addresses` field
      using the `operator` field.

      #### evmNetwork

      A criterion based on the intended network of the user operation. The
      `network` field in the `prepareUserOperation` request body is compared to
      the criterion's `networks` field using the `operator` field.

      Valid networks for this criterion include:
        - `base-sepolia`
        - `base`
        - `arbitrum`
        - `optimism`
        - `zora`
        - `polygon`
        - `bnb`
        - `avalanche`
        - `ethereum`
        - `ethereum-sepolia`

      #### evmData

      A criterion based on encoded transaction data that evaluates the function
      being called, as well as any number of arguments accessed by either name
      or index. Currently this criterion only supports primitive types;
      `string`, `bool`, `uint(8,16,32,64,256)`, `int(8,16,32,64,256)`,
      `address`, and both fixed and dynamic length `bytes`.

      ### SignEvmHash Criteria

      The `signEvmHash` operation does not accept any criteria. To prevent this
      operation from being executed by any account, specify a rule with
      `signEvmHash` as the operation, and `reject` as its action.

      ### SignEvmMessage Criteria

      #### evmMessage

      A criterion based on the intended message to be signed. The `match` field
      in the criteria is a [RE2](https://github.com/google/re2/wiki/Syntax)
      compliant regular expression that will be executed against the message in
      the API request.

      ### SignSolMessage Criteria

      #### solMessage

      A criterion based on the intended message to be signed. The `match` field
      in the criteria is a [RE2](https://github.com/google/re2/wiki/Syntax)
      compliant regular expression that will be executed against the message in
      the API request.

      ### SignSolTransaction Criteria

      #### solAddress

      A criterion based on the recipient addresses of the transaction. The
      criterion's `address` field is compared to the list of addresses in the
      transaction's `accountKeys` (for legacy transactions) or
      `staticAccountKeys` (for V0 transactions) array using the `operator`
      field.

      #### solValue

      A criterion based on the value of the transaction. The criterion's
      `solValue` field is compared to the transaction's `value`, which is the
      amount of SOL in lamports being transferred, using the `operator` field.

      #### splAddress

      A criterion based on the recipient addresses of SPL token transfer
      instructions in the transaction. The criterion's `addresses` field is
      compared to the list of SPL token transfer recipient addresses in the
      transaction's `accountKeys` (for legacy transactions) or
      `staticAccountKeys` (for V0 transactions) array using the `operator`
      field.

      #### splValue

      A criterion based on the SPL token value of SPL token transfer
      instructions in the transaction. The criterion's `splValue` field is
      compared to the transaction instruction's `value` field, which is the
      amount of the SPL token being transferred, using the `operator` field.

      #### mintAddress

      A criterion based on the token mint addresses of SPL token transfer
      instructions in the transaction. The criterion's `addresses` field is
      compared to the list of token mint addresses in the transaction's
      `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0
      transactions) array using the `operator` field.

      #### solData

      A criterion based on Solana transaction instruction data. The criterion
      uses Interface Definition Language (IDL) specifications to decode and
      validate instruction data against specific rules. The `idls` field
      specifies which Solana programs to validate against (either known program
      names like "SystemProgram" and "TokenProgram", or custom IDL objects), and
      the `conditions` field defines instruction-specific validation rules
      including instruction names and parameter constraints.

      #### programId

      A criterion based on the program IDs of a transaction's instructions. The
      criterion's `programIds` field is compared to the list of program IDs in
      the transaction's instructions using the `operator` field.

      ### SendSolTransaction Criteria

      #### solAddress

      A criterion based on the recipient addresses of the transaction. The
      criterion's `address` field is compared to the list of addresses in the
      transaction's `accountKeys` (for legacy transactions) or
      `staticAccountKeys` (for V0 transactions) array using the `operator`
      field.

      #### solValue

      A criterion based on the value of the transaction. The criterion's
      `solValue` field is compared to the transaction's `value`, which is the
      amount of SOL in lamports being transferred, using the `operator` field.

      #### splAddress

      A criterion based on the recipient addresses of SPL token transfer
      instructions in the transaction. The criterion's `addresses` field is
      compared to the list of SPL token transfer recipient addresses in the
      transaction's `accountKeys` (for legacy transactions) or
      `staticAccountKeys` (for V0 transactions) array using the `operator`
      field.

      #### splValue

      A criterion based on the SPL token value of SPL token transfer
      instructions in the transaction. The criterion's `splValue` field is
      compared to the transaction instruction's `value` field, which is the
      amount of the SPL token being transferred, using the `operator` field.

      #### mintAddress

      A criterion based on the token mint addresses of SPL token transfer
      instructions in the transaction. The criterion's `addresses` field is
      compared to the list of token mint addresses in the transaction's
      `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0
      transactions) array using the `operator` field.

      #### solData

      A criterion based on Solana transaction instruction data. The criterion
      uses Interface Definition Language (IDL) specifications to decode and
      validate instruction data against specific rules. The `idls` field
      specifies which Solana programs to validate against (either known program
      names like "SystemProgram" and "TokenProgram", or custom IDL objects), and
      the `conditions` field defines instruction-specific validation rules
      including instruction names and parameter constraints.

      #### programId

      A criterion based on the program IDs of a transaction's instructions. The
      criterion's `programIds` field is compared to the list of program IDs in
      the transaction's instructions using the `operator` field.

      #### solNetwork

      A criterion based on the intended network of the transaction. The
      `network` field in the `sendSolanaTransaction` request body is compared to
      the criterion's `networks` field using the `operator` field.

      Valid networks for this criterion include:
        - `solana-devnet`
        - `solana`

      ## Restricting Contract Interactions on Ethereum

      Smart contract function restrictions serve as a critical security and
      governance mechanism in decentralized applications, allowing developers
      and organizations to implement fine-grained access controls over their
      protocol interactions.

      One of the primary use cases for function restrictions is protecting
      high-risk operations from unauthorized access such as:

      - Fund transfers - Contract upgrades - Parameter modifications - Emergency
      pauses

      Policy Engine supports such restrictions that evaluate against transaction
      data with the `evmData` criterion for the `signEvmTransaction`, and
      `sendEvmTransaction` operations.

      ## Examples

      ### USD Limits

      The following example demonstrates a policy that only allows transactions
      to transfer, or expose the sender to, less than $100.00 worth of assets at
      a time. This USD denominated amount includes native assets, `ERC20`,
      `ERC721`, and `ERC1155` tokens calculated using current market prices.

      ```json {
        "scope": "account",
        "description": "Reject assets out over 100 USD",
        "rules": [
          {
            "action": "reject",
            "operation": "sendEvmTransaction",
            "criteria": [
              {
                "type": "netUSDChange",
                "changeCents": 10000,
                "operator": ">",
              },
            ],
          },
          {
            "action": "reject",
            "operation": "signEvmTransaction",
            "criteria": [
              {
                "type": "netUSDChange",
                "changeCents": 10000,
                "operator": ">",
              },
            ],
          },
        ],
      } ```

      ### Limiting USDC Spend

      This policy restricts USDC transactions on the Base network to transfers
      of 10,000 tokens or less. It applies to both signing and sending
      transactions to the USDC contract address, using the ERC20 ABI to validate
      that only `transfer` function calls with a `value` parameter under the
      specified limit are permitted.

      ```json {
        "description": "Limit USDC Spend",
        "scope": "account",
        "rules": [
          {
            "action": "accept",
            "operation": "sendEvmTransaction",
            "criteria": [
              {
                "type": "evmNetwork",
                "networks": ["base"],
                "operator": "in"
              },
              {
                "type": "evmAddress",
                "addresses": ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"],
                "operator": "in"
              },
              {
                "type": "evmData",
                "abi": "erc20",
                "conditions": [
                  {
                    "function": "transfer",
                    "params": [
                      {
                        "name": "value",
                        "operator": "<=",
                        "value": "10000"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "action": "accept",
            "operation": "signEvmTransaction",
            "criteria": [
              {
                "type": "evmAddress",
                "addresses": ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"],
                "operator": "in"
              },
              {
                "type": "evmData",
                "abi": "erc20",
                "conditions": [
                  {
                    "function": "transfer",
                    "params": [
                      {
                        "name": "value",
                        "operator": "<=",
                        "value": "10000"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      } ```.
  - name: Solana Accounts
    x-audience: public
    description: >-
      The Solana Account APIs enable you to create and use Solana accounts
      across SVM-compatible blockchains.


      An **account** is a private/public key pair that is used to sign
      transactions and messages. The private key is generated and used only in
      CDP's Trusted Execution Environment (TEE), and never exposed to Coinbase
      or the developer.


      A Solana account is identified by its **address**, which is a base-58
      encoded string.


      Accounts can optionally be assigned an **account name** at creation time
      for easier identification in subsequent API calls. Solana account names
      must be globally unique across all Solana accounts in the developer's CDP
      Project.


      ## Authentication


      The Solana Account APIs use two layers of authentication to ensure the
      security of your accounts' private keys:


      - **CDP Secret API Key**: This key is used to authenticate all requests to
      the entire suite of
         REST APIs offered on Coinbase Developer Platform.
      - **Wallet Secret**: This secret is used specifically to authenticate
      sensitive wallet operations
        to `POST` and `DELETE` endpoints in the EVM and Solana Account APIs.


      To learn more about creating and using these keys, visit our
      [Authentication
      docs](https://docs.cdp.coinbase.com/api-reference/v2/authentication).


      <Tip>



      **Use our SDK**



      The [CDP SDK](https://github.com/coinbase/cdp-sdk) automatically
      authenticates requests using your CDP Secret API Key and Wallet Secret.
      Use the CDP SDK for a more convenient access to our APIs.



      </Tip>
  - name: Solana Token Balances
    x-audience: public
    description: >-
      The Solana Token Balances APIs enable you to retrieve the balances of
      Solana addresses.

      This includes SPL tokens and the native SOL token of the network.

      ## Denomination

      - 'amount' is denominated in the smallest indivisible unit of the token.
      For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL
      tokens, the smallest unit is defined by the token's decimals
      configuration.

      - 'decimals' is the exponential value N that satisfies the equation
      `amount * 10^-N = standard_denomination`. The standard denomination is the
      most commonly used denomination for the token.

        - For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports).
        - For SPL tokens, `decimals` is defined in the token's mint configuration.
  - name: SQL API (Alpha)
    x-audience: public
    description: >-
      The SQL APIs enable you to write performant, high-freshness, and endlessly
      flexible SQL queries against onchain data.
  - name: Webhooks
    x-audience: public
    description: >-
      Subscribe to real-time events across CDP products. Monitor onchain
      activity on Base mainnet, track onramp/offramp transactions, and receive
      instant notifications for wallet events.
  - name: x402 Facilitator
    x-audience: public
    description: >-
      The x402 payment protocol is an HTTP-based payment protocol that enables
      developers running resource servers to accept payments from users using a
      variety of payment methods.

      For more details on the x402 payment protocol, please see the [x402
      specification](https://www.x402.org/).

      The x402 Facilitator APIs enable you to facilitate payments using the x402
      payment protocol by exposing two APIs:

      - `POST /v2/x402/verify`: Verify a payment with a supported scheme and
      network.

      - `POST /v2/x402/settle`: Settle a payment with a supported scheme and
      network.
paths:
  /v2/end-users/{userId}:
    get:
      tags:
        - End User Accounts
      summary: Get an end user
      description: >-
        Gets an end user by ID.


        This API is intended to be used by the developer's own backend, and is
        authenticated using the developer's CDP API key.
      operationId: getEndUser
      parameters:
        - name: userId
          in: path
          required: true
          description: The ID of the end user to get.
          schema:
            type: string
            pattern: ^[a-zA-Z0-9-]{1,100}$
          example: e051beeb-7163-4527-a5b6-35e301529ff2
      responses:
        '200':
          description: Successfully got end user.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EndUser'
        '404':
          description: Not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
              examples:
                not_found:
                  value:
                    errorType: not_found
                    errorMessage: End user with the given ID not found.
        '500':
          $ref: '#/components/responses/InternalServerError'
      security:
        - apiKeyAuth: []
components:
  schemas:
    EndUser:
      type: object
      description: Information about the end user.
      properties:
        userId:
          description: >-
            A stable, unique identifier for the end user. The `userId` must be
            unique across all end users in the developer's CDP Project. It must
            be between 1 and 100 characters long and can only contain
            alphanumeric characters and hyphens.
          type: string
          pattern: ^[a-zA-Z0-9-]{1,100}$
          example: e051beeb-7163-4527-a5b6-35e301529ff2
        authenticationMethods:
          $ref: '#/components/schemas/AuthenticationMethods'
        mfaMethods:
          $ref: '#/components/schemas/MFAMethods'
        evmAccounts:
          type: array
          deprecated: true
          description: >-
            **DEPRECATED**: Use `evmAccountObjects` instead for richer account
            information. The list of EVM account addresses associated with the
            end user. End users can have up to 10 EVM accounts.
          items:
            type: string
            description: The address of the EVM account associated with the end user.
            pattern: ^0x[0-9a-fA-F]{40}$
            example: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
          example:
            - '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
        evmAccountObjects:
          type: array
          description: >-
            The list of EVM accounts associated with the end user. End users can
            have up to 10 EVM accounts.
          items:
            $ref: '#/components/schemas/EndUserEvmAccount'
          example:
            - address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
              createdAt: '2025-01-15T10:30:00Z'
            - address: '0x1234567890abcdef1234567890abcdef12345678'
              createdAt: '2025-01-15T11:00:00Z'
        evmSmartAccounts:
          type: array
          deprecated: true
          description: >-
            **DEPRECATED**: Use `evmSmartAccountObjects` instead for richer
            account information including owner relationships. The list of EVM
            smart account addresses associated with the end user. Each EVM EOA
            can own one smart account.
          items:
            type: string
            description: The address of the EVM smart account associated with the end user.
            pattern: ^0x[0-9a-fA-F]{40}$
            example: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
          example:
            - '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
        evmSmartAccountObjects:
          type: array
          description: >-
            The list of EVM smart accounts associated with the end user. Each
            EVM EOA can own one smart account.
          items:
            $ref: '#/components/schemas/EndUserEvmSmartAccount'
          example:
            - address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
              ownerAddresses:
                - '0x1234567890abcdef1234567890abcdef12345678'
                - '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd'
              createdAt: '2025-01-15T12:00:00Z'
        solanaAccounts:
          type: array
          deprecated: true
          description: >-
            **DEPRECATED**: Use `solanaAccountObjects` instead for richer
            account information. The list of Solana account addresses associated
            with the end user. End users can have up to 10 Solana accounts.
          items:
            type: string
            description: >-
              The base58 encoded address of the Solana account associated with
              the end user.
            pattern: ^[1-9A-HJ-NP-Za-km-z]{32,44}$
            example: HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT
          example:
            - HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT
        solanaAccountObjects:
          type: array
          description: >-
            The list of Solana accounts associated with the end user. End users
            can have up to 10 Solana accounts.
          items:
            $ref: '#/components/schemas/EndUserSolanaAccount'
          example:
            - address: HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT
              createdAt: '2025-01-15T10:30:00Z'
            - address: 9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin
              createdAt: '2025-01-15T11:30:00Z'
        createdAt:
          type: string
          format: date-time
          description: The date and time when the end user was created, in ISO 8601 format.
          example: '2025-01-15T10:30:00Z'
      required:
        - userId
        - authenticationMethods
        - evmAccounts
        - evmAccountObjects
        - evmSmartAccounts
        - evmSmartAccountObjects
        - solanaAccounts
        - solanaAccountObjects
        - createdAt
    Error:
      description: >-
        An error response including the code for the type of error and a
        human-readable message describing the error.
      type: object
      properties:
        errorType:
          $ref: '#/components/schemas/ErrorType'
        errorMessage:
          description: The error message.
          type: string
          example: Unable to create EVM account
        correlationId:
          description: >-
            A unique identifier for the request that generated the error. This
            can be used to help debug issues with the API.
          type: string
          example: 41deb8d59a9dc9a7-IAD
        errorLink:
          allOf:
            - $ref: '#/components/schemas/Url'
          description: A link to the corresponding error documentation.
          example: >-
            https://docs.cdp.coinbase.com/api-reference/v2/errors#invalid-request
      required:
        - errorType
        - errorMessage
      example:
        errorType: invalid_request
        errorMessage: Invalid request.
        correlationId: 41deb8d59a9dc9a7-IAD
        errorLink: https://docs.cdp.coinbase.com/api-reference/v2/errors#invalid-request
    AuthenticationMethods:
      type: array
      description: The list of valid authentication methods linked to the end user.
      items:
        $ref: '#/components/schemas/AuthenticationMethod'
      example:
        - type: email
          email: user@example.com
        - type: sms
          phoneNumber: '+12055555555'
        - type: jwt
          sub: e051beeb-7163-4527-a5b6-35e301529ff2
          kid: NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg
        - type: google
          sub: '115346410074741490243'
          email: test.user@gmail.com
        - type: telegram
          id: 1223456
          firstName: Satoshi
          lastName: Nakamoto
          photoUrl: https://image.url/profile.jpg
          authDate: 1770681412
          username: satoshinakamoto
    MFAMethods:
      x-audience: public
      description: |
        Information about the end user's MFA enrollments.
      type: object
      properties:
        enrollmentPromptedAt:
          type: string
          format: date-time
          description: >-
            The date and time when the end user was prompted for MFA enrollment,
            in ISO 8601 format. If the this field exists, and the user has no
            other enrolled MFA methods, then the user skipped MFA enrollment.
          example: '2025-01-15T10:30:00Z'
        totp:
          type: object
          description: >-
            An object containing information about the end user's TOTP
            enrollment.
          required:
            - enrolledAt
          properties:
            enrolledAt:
              type: string
              format: date-time
              description: >-
                The date and time when the method was enrolled, in ISO 8601
                format.
              example: '2025-01-15T10:30:00Z'
        sms:
          type: object
          description: >-
            An object containing information about the end user's SMS MFA
            enrollment.
          required:
            - enrolledAt
          properties:
            enrolledAt:
              type: string
              format: date-time
              description: >-
                The date and time when the method was enrolled, in ISO 8601
                format.
              example: '2025-01-15T10:30:00Z'
      example:
        enrollmentPromptedAt: '2025-01-15T10:30:00Z'
        totp:
          enrolledAt: '2025-01-15T10:30:00Z'
        sms:
          enrolledAt: '2025-01-15T10:30:00Z'
    EndUserEvmAccount:
      type: object
      description: Information about an EVM account associated with an end user.
      properties:
        address:
          type: string
          description: The address of the EVM account.
          pattern: ^0x[0-9a-fA-F]{40}$
          example: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
        createdAt:
          type: string
          format: date-time
          description: The date and time when the account was created, in ISO 8601 format.
          example: '2025-01-15T10:30:00Z'
      required:
        - address
        - createdAt
    EndUserEvmSmartAccount:
      type: object
      description: Information about an EVM smart account associated with an end user.
      properties:
        address:
          type: string
          description: The address of the EVM smart account.
          pattern: ^0x[0-9a-fA-F]{40}$
          example: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'
        ownerAddresses:
          type: array
          description: >-
            The addresses of the EVM EOA accounts that own this smart account.
            Smart accounts can have multiple owners, such as when spend
            permissions are enabled.
          items:
            type: string
            description: The address of an EVM EOA account that owns this smart account.
            pattern: ^0x[0-9a-fA-F]{40}$
            example: '0x1234567890abcdef1234567890abcdef12345678'
          example:
            - '0x1234567890abcdef1234567890abcdef12345678'
            - '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd'
        createdAt:
          type: string
          format: date-time
          description: The date and time when the account was created, in ISO 8601 format.
          example: '2025-01-15T10:30:00Z'
      required:
        - address
        - ownerAddresses
        - createdAt
    EndUserSolanaAccount:
      type: object
      description: Information about a Solana account associated with an end user.
      properties:
        address:
          type: string
          description: The base58 encoded address of the Solana account.
          pattern: ^[1-9A-HJ-NP-Za-km-z]{32,44}$
          example: HpabPRRCFbBKSuJr5PdkVvQc85FyxyTWkFM2obBRSvHT
        createdAt:
          type: string
          format: date-time
          description: The date and time when the account was created, in ISO 8601 format.
          example: '2025-01-15T10:30:00Z'
      required:
        - address
        - createdAt
    ErrorType:
      description: >-
        The code that indicates the type of error that occurred. These error
        codes can be used to determine how to handle the error.
      type: string
      example: invalid_request
      enum:
        - already_exists
        - bad_gateway
        - faucet_limit_exceeded
        - forbidden
        - idempotency_error
        - internal_server_error
        - invalid_request
        - invalid_sql_query
        - invalid_signature
        - malformed_transaction
        - not_found
        - payment_method_required
        - rate_limit_exceeded
        - request_canceled
        - service_unavailable
        - timed_out
        - unauthorized
        - policy_violation
        - policy_in_use
        - account_limit_exceeded
        - network_not_tradable
        - guest_permission_denied
        - guest_region_forbidden
        - guest_transaction_limit
        - guest_transaction_count
        - phone_number_verification_expired
        - document_verification_failed
        - recipient_allowlist_violation
        - recipient_allowlist_pending
        - travel_rules_recipient_violation
        - source_account_invalid
        - target_account_invalid
        - source_account_not_found
        - target_account_not_found
        - source_asset_not_supported
        - target_asset_not_supported
        - target_email_invalid
        - target_onchain_address_invalid
        - transfer_amount_invalid
        - transfer_asset_not_supported
        - insufficient_balance
        - metadata_too_many_entries
        - metadata_key_too_long
        - metadata_value_too_long
        - travel_rules_field_missing
        - asset_mismatch
        - mfa_already_enrolled
        - mfa_invalid_code
        - mfa_flow_expired
        - mfa_required
        - mfa_not_enrolled
      x-error-instructions:
        already_exists: >-
          This error occurs when trying to create a resource that already
          exists.


          **Steps to resolve:**

          1. Check if the resource exists before creation

          2. Use GET endpoints to verify resource state

          3. Use unique identifiers/names for resources
        bad_gateway: >-
          This error occurs when the CDP API is unable to connect to the backend
          service.


          **Steps to resolve:**

          1. Retry your request after a short delay

          2. If persistent, contact CDP support with:
             - The timestamp of the error
             - Request details
          3. Consider implementing retry logic with an exponential backoff


          **Note:** These errors are automatically logged and monitored by CDP.
        faucet_limit_exceeded: >-
          This error occurs when you've exceeded the faucet request limits.


          **Steps to resolve:**

          1. Wait for the time window to reset

          2. Use funds more efficiently in your testing


          For more information on faucet limits, please visit the [EVM Faucet
          endpoint](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/faucets/request-funds-on-evm-test-networks)
          or the [Solana Faucet
          endpoint](https://docs.cdp.coinbase.com/api-reference/v2/rest-api/faucets/request-funds-on-solana-devnet).
        forbidden: >-
          This error occurs when you don't have permission to access the
          resource.


          **Steps to resolve:**

          1. Verify your permissions to access the resource

          2. Ensure that you are the owner of the requested resource
        idempotency_error: >-
          This error occurs when an idempotency key is reused with different
          parameters.


          **Steps to resolve:**

          1. Generate a new UUID v4 for each unique request

          2. Only reuse idempotency keys for exact request duplicates

          3. Track used keys within your application


          **Example idempotency key implementation:**

          ```typescript lines wrap

          import { v4 as uuidv4 } from 'uuid';


          function createIdempotencyKey() {
            return uuidv4();
          }

          ```
        internal_server_error: >-
          This indicates an unexpected error that occurred on the CDP servers.


          **Important**: If you encounter this error, please note that your
          operation's status should be treated as unknown by your application,
          as it could have been a success within the CDP back-end.


          **Steps to resolve:**

          1. Retry your request after a short delay

          2. If persistent, contact CDP support with:
             - Your correlation ID
             - Timestamp of the error
             - Request details
          3. Consider implementing retry logic with an exponential backoff


          **Note:** These errors are automatically logged and monitored by CDP.
        invalid_request: >-
          This error occurs when the request is malformed or contains invalid
          data, including issues with the request body, query parameters, path
          parameters, or headers.


          **Steps to resolve:**

          1. Check all required fields and parameters are present

          2. Ensure request body (if applicable) follows the correct schema

          3. Verify all parameter formats match the API specification:
             - Query parameters
             - Path parameters
             - Request headers
          4. Validate any addresses, IDs, or other formatted strings meet
          requirements


          **Common validation issues:**

          - Missing required parameters

          - Invalid parameter types or formats

          - Malformed JSON in request body

          - Invalid enum values
        invalid_sql_query: |-
          This error occurs when the SQL query is invalid or not allowed.

          **Common causes:**
          - Using non-SELECT SQL statements (INSERT, UPDATE, DELETE, etc.)
          - Invalid table or column names
          - Syntax errors in SQL query
          - Query exceeds character limit
          - Too many JOIN operations
        invalid_signature: >-
          This error occurs when the signature provided for the given user
          operation is invalid.


          **Steps to resolve:**

          1. Verify the signature was generated by the correct owner account

          2. Ensure the signature corresponds to the exact user operation hash

          3. Check that the signature format matches the expected format

          4. Confirm you're using the correct network for the Smart Account


          **Common causes:**

          - Using wrong owner account to sign

          - Signing modified/incorrect user operation data

          - Malformed signature encoding

          - Network mismatch between signature and broadcast
        malformed_transaction: >-
          This error occurs when the transaction data provided is not properly
          formatted or is invalid.


          **Steps to resolve:**

          1. Verify transaction encoding:
             - **EVM networks**: Check RLP encoding is correct
             - **Solana**: Validate base64 encoding
          2. Ensure all required transaction fields are present

          3. Validate transaction parameters are within acceptable ranges

          4. Check that the transaction type is supported on the target network
          (see our [Supported
          Networks](https://docs.cdp.coinbase.com/get-started/supported-networks)
          page for more details)


          **Common causes:**

          - Invalid hex encoding for EVM transactions

          - Missing required transaction fields

          - Incorrect parameter formats

          - Unsupported transaction types

          - Network-specific transaction format mismatches
        not_found: >-
          This error occurs when the resource specified in your request doesn't
          exist or you don't have access to it.


          **Steps to resolve:**

          1. Verify the resource ID/address/account exists

          2. Check your permissions to access the resource

          3. Ensure you're using the correct network/environment

          4. Confirm the resource hasn't been deleted


          **Common causes:**

          - Mistyped addresses

          - Accessing resources from the wrong CDP project

          - Resource was deleted or hasn't been created yet
        payment_method_required: >-
          This error occurs when a payment method is required to complete the
          requested operation but none is configured or available.


          **Steps to resolve:**

          1. Add a valid payment method to your account using the [CDP
          Portal](https://portal.cdp.coinbase.com)

          2. Ensure your payment method is valid and not expired


          **Common causes:**

          - No payment method configured on the account

          - Payment method is expired
        rate_limit_exceeded: |-
          This error occurs when you've exceeded the API rate limits.

          **Steps to resolve:**
          1. Implement exponential backoff
          2. Cache responses where possible
          3. Wait for rate limit window to reset

          **Best practices:**
          ```typescript lines wrap
          async function withRetry(fn: () => Promise<any>) {
            let delay = 1000;
            while (true) {
              try {
                return await fn();
              } catch (e) {
                if (e.errorType === "rate_limit_exceeded") {
                  await sleep(delay);
                  delay *= 2;
                  continue;
                }
                throw e;
              }
            }
          }
          ```
        request_canceled: >-
          This error occurs when the client cancels an in-progress request
          before it completes.


          **Steps to resolve:**

          1. Check client-side timeout configurations

          2. Review request cancellation logic in your code

          3. Consider increasing timeout thresholds for long-running operations

          4. Implement request tracking to identify premature cancellations


          **Best practices:**

          ```typescript lines wrap

          async function withTimeout<T>(promise: Promise<T>, timeoutMs: number):
          Promise<T> {
            const timeout = new Promise((_, reject) => {
              setTimeout(() => {
                reject(new Error("Operation timed out"));
              }, timeoutMs);
            });

            try {
              return await Promise.race([promise, timeout]);
            } catch (error) {
              // Handle timeout or cancellation
              throw error;
            }
          }

          ```
        service_unavailable: >-
          This error occurs when the CDP API is temporarily unable to handle
          requests due to maintenance or high load.


          **Steps to resolve:**

          1. Retry your request after a short delay

          2. If persistent, contact CDP support with:
             - The timestamp of the error
             - Request details
          3. Consider implementing retry logic with an exponential backoff


          **Note:** These errors are automatically logged and monitored by CDP.
        timed_out: >-
          This error occurs when a request exceeds the maximum allowed
          processing time.


          **Steps to resolve:**

          1. Break down large requests into smaller chunks (if applicable)

          2. Implement retry logic with exponential backoff

          3. Use streaming endpoints for large data sets


          **Example retry implementation:**

          ```typescript lines wrap

          async function withRetryAndTimeout<T>(
            operation: () => Promise<T>,
            maxRetries = 3,
            timeout = 30000,
          ): Promise<T> {
            let attempts = 0;
            while (attempts < maxRetries) {
              try {
                return await Promise.race([
                  operation(),
                  new Promise((_, reject) =>
                    setTimeout(() => reject(new Error("Timeout")), timeout)
                  ),
                ]);
              } catch (error) {
                attempts++;
                if (attempts === maxRetries) throw error;
                // Exponential backoff
                await new Promise(resolve =>
                  setTimeout(resolve, Math.pow(2, attempts) * 1000)
                );
              }
            }
            throw new Error("Max retries exceeded");
          }

          ```
        unauthorized: |-
          This error occurs when authentication fails.

          **Steps to resolve:**
          1. Verify your CDP API credentials:
             - Check that your API key is valid
             - Check that your Wallet Secret is properly configured
          2. Validate JWT token:
             - Not expired
             - Properly signed
             - Contains required claims
          3. Check request headers:
             - Authorization header present
             - X-Wallet-Auth header included when required

          **Security note:** Never share your Wallet Secret or API keys.
        policy_in_use: >-
          This error occurs when trying to delete a Policy that is currently in
          use by at least one project or account.


          **Steps to resolve:**

          1. Update project or accounts to remove references to the Policy in
          question.

          2. Retry your delete request.
        network_not_tradable: >-
          This error occurs when the selected asset cannot be purchased on the
          selected network in the user's location.


          **Steps to resolve:**

          1. Verify the asset is tradable on the selected network

          2. Check the user's location to ensure it is allowed to purchase the
          asset on the selected network


          **Common causes:**

          - Users in NY are not allowed to purchase USDC on any network other
          than Ethereum
        guest_permission_denied: >-
          This error occurs when the user is not allowed to complete onramp
          transactions as a guest.


          **Steps to resolve:**

          1. Redirect the user to create a Coinbase account to buy and send
          crypto.
        guest_region_forbidden: >-
          This error occurs when guest onramp transactions are not allowed in
          the user's region.


          **Steps to resolve:**

          1. Redirect the user to create a Coinbase account to buy and send
          crypto.
        guest_transaction_limit: >-
          This error occurs when the user has reached the weekly guest onramp
          transaction limit.


          **Steps to resolve:**

          1. Inform the user they have reached their weekly limit and will have
          to wait until next week.
        guest_transaction_count: >-
          This error occurs when the user has reached the lifetime guest onramp
          transaction count limit.


          **Steps to resolve:**

          1. Redirect the user to create a Coinbase account to buy and send
          crypto.
        phone_number_verification_expired: >-
          This error occurs when the user's phone number verification has
          expired. Use of guest Onramp requires the user's

          phone number to be verified every 60 days.


          **Steps to resolve:**

          1. Re-verify the user's phone number via OTP.

          2. Retry the request with the phoneNumberVerifiedAt field set to new
          verification timestamp.
        document_verification_failed: >-
          This error occurs when the user has not verified their identity for
          their coinbase.com account.

          **Steps to resolve:**

          1. Verify your coinbase account identity with valid documents at
          https://www.coinbase.com/settings/account-levels.
        recipient_allowlist_violation: >-
          This error occurs when the user is not allowed to receive funds at
          this address, according to their coinbase account allowlist.

          **Steps to resolve:**

          1. Either disable the allowlist or add the wallet address at
          https://www.coinbase.com/settings/allowlist

          2. Wait approximately 2 days for updates to take effect.
        recipient_allowlist_pending: >-
          This error occurs when the user is not allowed to receive funds at
          this address, because changes to their coinbase account allowlist are
          pending.

          **Steps to resolve:**

          1. Wait approximately 2 days for updates to take effect.
        travel_rules_recipient_violation: >-
          This error occurs when the user is not allowed to receive funds at
          this address, because it violates travel rules.

          **Steps to resolve:**

          1. Ensure your desired transfer is not blocked by local travel
          regulations.
        mfa_already_enrolled: >-
          This error occurs when attempting to enroll in an MFA method that the
          user has already enrolled in.


          **Steps to resolve:**

          1. Check if the user is already enrolled in the MFA method before
          initiating enrollment

          2. To update or reset MFA, remove the existing enrollment first (if
          supported)

          3. Use a different MFA method if multiple options are available
        mfa_invalid_code: >-
          This error occurs when the MFA code provided is incorrect or has
          already been used.


          **Steps to resolve:**

          1. Verify the user entered the correct code from their authenticator
          app

          2. Ensure the code is current (TOTP codes expire after 30 seconds)

          3. Check that the device time is synchronized correctly

          4. Ask the user to generate a new code and try again


          **Common causes:**

          - Typing errors in the 6-digit code

          - Using an expired TOTP code

          - Device clock drift on user's authenticator app

          - Attempting to reuse a previously submitted code
        mfa_flow_expired: >-
          This error occurs when the MFA enrollment or verification session has
          expired.


          **Steps to resolve:**

          1. Restart the MFA enrollment or verification flow

          2. Complete the flow within the allowed time window (typically 5
          minutes)

          3. Ensure the user doesn't leave the flow idle for extended periods


          **Note:** MFA sessions expire automatically for security purposes.
        mfa_required: >-
          This error occurs when attempting to perform a sensitive operation
          that requires MFA verification, but the user has not completed MFA
          verification.


          **Steps to resolve:**

          1. Initiate the MFA verification flow using the
          `/mfa/verify/{mfaMethod}/init` endpoint

          2. Prompt the user to enter their MFA code

          3. Submit the verification using the `/mfa/verify/{mfaMethod}/submit`
          endpoint

          4. Use the returned access token with MFA claim for the sensitive
          operation

          5. Retry the original request with the new MFA-verified token


          **Operations requiring MFA:**

          - Transactions Sign/Send

          - Key export

          - Account management actions (when configured)
        mfa_not_enrolled: >-
          This error occurs when attempting to verify MFA for a user who has not
          enrolled in any MFA method.


          **Steps to resolve:**

          1. Check if the user has enrolled in MFA before attempting
          verification

          2. Guide the user through MFA enrollment first using the
          `/mfa/enroll/{mfaMethod}/init` endpoint

          3. Complete enrollment before requiring MFA verification
        source_account_invalid: >-
          This error occurs when the source account specified in the transfer
          request is invalid or malformed.


          **Steps to resolve:**

          1. Verify the account ID format is correct (e.g.,
          `account_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)

          2. Ensure the account ID belongs to your CDP entity

          3. Verify the account ID exists by calling `GET
          /v2/accounts/{accountId}` or `GET /v2/accounts`


          **Common causes:**

          - Malformed account ID

          - Typo in the account ID
        target_account_invalid: >-
          This error occurs when the target account specified in the transfer
          request is invalid or malformed.


          **Steps to resolve:**

          1. Verify the account ID format is correct (e.g.,
          `account_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)

          2. Ensure the account exists and can receive funds

          3. Verify the account ID exists by calling `GET
          /v2/accounts/{accountId}` or `GET /v2/accounts`


          **Common causes:**

          - Malformed account ID

          - Typo in the account ID
        source_account_not_found: >-
          This error occurs when the source account specified in the transfer
          does not exist.


          **Steps to resolve:**

          1. Verify the account ID exists by calling `GET
          /v2/accounts/{accountId}` or `GET /v2/accounts`
        target_account_not_found: >-
          This error occurs when the target account specified in the transfer
          does not exist.


          **Steps to resolve:**

          1. Verify the account ID exists by calling `GET
          /v2/accounts/{accountId}` or `GET /v2/accounts`
        source_asset_not_supported: >-
          This error occurs when the asset specified in the transfer source is
          not supported for this transfer type.


          **Steps to resolve:**

          1. Check the list of supported assets for the source account type

          2. Verify the asset symbol is correctly specified (e.g., `usdc`,
          `usdt`)


          **Common causes:**

          - Unsupported asset for the transfer route

          - Incorrect asset symbol
        target_asset_not_supported: >-
          This error occurs when the asset specified in the transfer target is
          not supported for this transfer type.


          **Steps to resolve:**

          1. Check the list of supported assets for the target

          2. Verify the asset symbol is correctly specified (e.g., `usdc`,
          `usdt`)

          3. Ensure the target can receive this asset type


          **Common causes:**

          - Asset not supported by the target

          - Unsupported conversion between source and target assets
        target_email_invalid: >-
          This error occurs when the email address specified as the transfer
          target is invalid.


          **Steps to resolve:**

          1. Verify the email address format is valid (e.g., `user@example.com`)

          2. Check for typos in the email address

          3. Ensure the email domain is valid


          **Common causes:**

          - Invalid email format

          - Missing @ symbol or domain

          - Typo in the email address
        target_onchain_address_invalid: >-
          This error occurs when the onchain address specified as the transfer
          target is invalid for the specified network.


          **Steps to resolve:**

          1. Ensure the network is supported for the transfer type

          2. Verify the address format matches the target network

          3. Ensure you haven't mixed up addresses from different networks


          **Common causes:**

          - Network not supported for the transfer type

          - Address format doesn't match network

          - Address from a different blockchain network
        transfer_amount_invalid: >-
          This error occurs when the transfer amount is invalid.


          **Steps to resolve:**

          1. Ensure the amount is a positive number and greater than $1 USD
          equivalent amount

          2. Verify the amount format is a valid decimal string (e.g.,
          `"100.50"`)

          3. Check the number of decimal places for the asset


          **Common causes:**

          - Zero or negative amount

          - Too many decimal places for the asset

          - Amount below minimum threshold ($1 USD equivalent amount)
        transfer_asset_not_supported: >-
          This error occurs when the asset specified for the transfer is not
          supported.


          **Steps to resolve:**

          1. Check the list of supported assets for transfers

          2. Verify the asset symbol is correctly specified

          3. Ensure the asset is supported for the transfer route (source 
          target)


          **Common causes:**

          - Asset not supported for transfers

          - Incorrect asset symbol
        insufficient_balance: >-
          This error occurs when the source account does not have enough funds
          to complete the transfer including fees.


          **Steps to resolve:**

          1. Check the source account balance

          2. Ensure the balance covers both the transfer amount and any fees

          3. Consider using `amountType: "source"` to transfer the maximum
          available amount minus fees

          4. Add funds to the source account if needed


          **Common causes:**

          - Transfer amount exceeds available balance

          - Not accounting for transfer fees

          - Pending transactions reducing available balance
        metadata_too_many_entries: >-
          This error occurs when the transfer metadata contains more entries
          than allowed.


          **Steps to resolve:**

          1. Reduce the number of metadata entries (maximum 10 allowed)

          2. Consolidate related data into fewer keys

          3. Store additional data externally and reference it with a single
          metadata entry


          **Limits:**

          - Maximum entries: 10
        metadata_key_too_long: >-
          This error occurs when a metadata key exceeds the maximum allowed
          length.


          **Steps to resolve:**

          1. Shorten the metadata key to 40 characters or less

          2. Use abbreviations or shorter naming conventions

          3. Consider using a key-value structure where the value contains the
          longer identifier


          **Limits:**

          - Maximum key length: 40 characters
        metadata_value_too_long: >-
          This error occurs when a metadata value exceeds the maximum allowed
          length.


          **Steps to resolve:**

          1. Shorten the metadata value to 500 characters or less

          2. Store longer data externally and reference it with a shorter
          identifier

          3. Consider compressing or encoding the data if appropriate


          **Limits:**

          - Maximum value length: 500 characters
        travel_rules_field_missing: >-
          This error occurs when required travel rule fields are missing from
          the transfer request.


          **Steps to resolve:**

          1. Include the `travelRule` object in your transfer request

          2. Supply the required missing fields prompted by the error message

          3. Review the travel rule requirements for your jurisdiction


          Note: Required fields may vary by region.
        asset_mismatch: >-
          This error occurs when the assets specified in the transfer are
          incompatible or don't match expected values.


          **Steps to resolve:**

          1. Ensure the `asset` field matches either the source or target asset

          2. Verify that the source and target assets are compatible for
          conversion (if different)

          3. Check that the asset symbols are correctly specified


          **Common causes:**

          - Transfer asset doesn't match source or target

          - Attempting an unsupported asset conversion

          - Typo in asset symbols
    Url:
      type: string
      format: uri
      minLength: 11
      maxLength: 2048
      pattern: ^https?://.*$
      description: A valid HTTP or HTTPS URL.
      example: https://example.com
    AuthenticationMethod:
      description: Information about how the end user is authenticated.
      oneOf:
        - $ref: '#/components/schemas/EmailAuthentication'
        - $ref: '#/components/schemas/SmsAuthentication'
        - $ref: '#/components/schemas/DeveloperJWTAuthentication'
        - $ref: '#/components/schemas/OAuth2Authentication'
        - $ref: '#/components/schemas/TelegramAuthentication'
    EmailAuthentication:
      type: object
      title: EmailAuthentication
      description: >-
        Information about an end user who authenticates using a one-time
        password sent to their email address.
      properties:
        type:
          type: string
          description: The type of authentication information.
          example: email
          enum:
            - email
        email:
          type: string
          description: The email address of the end user.
          example: user@example.com
          format: email
      required:
        - type
        - email
    SmsAuthentication:
      type: object
      title: SmsAuthentication
      description: >-
        Information about an end user who authenticates using a one-time
        password sent to their phone number via SMS.
      properties:
        type:
          type: string
          description: The type of authentication information.
          example: sms
          enum:
            - sms
        phoneNumber:
          type: string
          description: The phone number of the end user in E.164 format.
          example: '+12055555555'
          pattern: ^\+[1-9]\d{1,14}$
      required:
        - type
        - phoneNumber
    DeveloperJWTAuthentication:
      type: object
      title: DeveloperJWTAuthentication
      description: >-
        Information about an end user who authenticates using a JWT issued by
        the developer.
      properties:
        type:
          type: string
          description: The type of authentication information.
          enum:
            - jwt
          example: jwt
        kid:
          type: string
          description: The key ID of the JWK used to sign the JWT.
          example: NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg
        sub:
          type: string
          description: >-
            The unique identifier for the end user that is captured in the `sub`
            claim of the JWT.
          example: e051beeb-7163-4527-a5b6-35e301529ff2
      required:
        - type
        - sub
        - kid
    OAuth2Authentication:
      type: object
      title: OAuth2Authentication
      description: >-
        Information about an end user who authenticates using a third-party
        provider.
      properties:
        type:
          $ref: '#/components/schemas/OAuth2ProviderType'
        sub:
          type: string
          description: >-
            The unique identifier for the end user that is captured in the `sub`
            claim of the JWT.
          example: e051beeb-7163-4527-a5b6-35e301529ff2
        email:
          type: string
          description: >-
            The email address of the end user contained within the user's ID
            token, if available from third-party OAuth2 provider's token
            exchange.
          example: test.user@gmail.com
        name:
          type: string
          description: >-
            The full name of the end user if available from third-party OAuth2
            provider's token exchange.
          example: Test User
        username:
          type: string
          description: >-
            The username of the end user if available from third-party OAuth2
            provider's token exchange.
          example: test.user
      required:
        - type
        - sub
    TelegramAuthentication:
      type: object
      description: Information about an end user who authenticates using Telegram.
      properties:
        type:
          $ref: '#/components/schemas/OAuth2ProviderType'
        id:
          type: integer
          description: The Telegram ID for the end user.
          example: 123456
        firstName:
          type: string
          description: The Telegram user's first name.
          example: Satoshi
        lastName:
          type: string
          description: The Telegram user's last name.
          example: Nakamoto
        photoUrl:
          type: string
          description: The Telegram user's profile picture.
          example: https://image.url/profile.png
        authDate:
          type: integer
          description: The Telegram user's last login as a Unix timestamp.
          example: 1770681412
        username:
          type: string
          description: The Telegram user's username.
          example: satoshinakamoto
      required:
        - type
        - id
        - firstName
        - lastName
        - photoUrl
        - authDate
        - username
    OAuth2ProviderType:
      type: string
      description: The type of OAuth2 provider.
      enum:
        - google
        - apple
        - x
        - telegram
      example: google
  responses:
    InternalServerError:
      description: Internal server error.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
          examples:
            internal_server_error:
              value:
                errorType: internal_server_error
                errorMessage: An internal server error occurred. Please try again later.
  securitySchemes:
    apiKeyAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: >-
        A JWT signed using your CDP API Key Secret, encoded in base64. Refer to
        the [Generate Bearer
        Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-bearer-token)
        section of our Authentication docs for information on how to generate
        your Bearer Token.

````